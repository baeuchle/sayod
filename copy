#!/bin/bash

exec_dir=$(dirname $0)
if [ "$(which notify-send)" == "" ]; then
    echo "Kann notify-send nicht finden, bitte installieren" >&2
    exit 127
fi

# make sure notify-send works from cronjob
if [ -z "$XDG_RUNTIME_DIR" ]; then
    export XDG_RUNTIME_DIR=/run/user/$(id -u)
fi
# same for zenity
if [ -z "$DISPLAY" ]; then
    export DISPLAY=:0.0
fi

function verbose_echo {
    if [ -z "$verbose" ]; then
        return
    fi
    echo -e "$(sed 's/\\n/\n/g' <<<$* | fold -w 72 -s)"
}

# may be used as provide script if user interaction is required.
function ask_provide {
    timeout=$1;
    shift;
    question="$*"
    zenity --question --timeout=$timeout --title "Backup $friendly_rc" --text="$question"
    case "$?" in
        0)
            return 0
        ;;
        1)
            notify ABORT "Bereitstellen abgebrochen"
            exit 0
        ;;
        5)
            notify ABORT "Bereitstellen dauerte zu lange"
            exit 0
        ;;
        *)
            return $?
        ;;
    esac
}

# may be used in provide_unless directives
function dir_exists {
    [[ -d "$*" ]]
    return $?
}

# may be used in provide_unless directives
function is_mountpoint {
    dir="$*"
    if [ "$dir" != "/" ]; then
        dir=${dir%/}
    fi
    if [ -z "$dir" ]; then return 2; fi
    mount | grep -q " $dir "
    return $?
}

function cleanup {
    for part in target source; do
        clean_cmd=$($config --section $part --key release --emptydefault)
        if [ ! -z "$clean_cmd" ]; then
            $clean_cmd
        fi
    done
    if [ -f "$rsyncerrfile" ]; then
        rm "$rsyncerrfile"
    fi
    if [ -f "$rsynclogfile" ]; then
        if [[ $rsynclogfile == /tmp/* ]]; then
            rm "$rsynclogfile"
        fi
    fi
}
trap cleanup EXIT

function readlog {
    loghost=$($config --section notify --key host --default localhost)
    loguser=$($config --section notify --key user --default $LOGNAME)
    logremote=$($config --section notify --key remotekey --default $stripped_rc)
    logmsg="content-type: text/x-plain-ask\n$logremote\nSUCCESS\n\nlast"
    echo -e "$logmsg" | ssh $loguser@$loghost logreader | awk '{print $1}'
    if [ $? -ne 0 ]; then
        notify-send -u low -t 3000 "Backup-Fehler ${rc/.rc/}" "Kann entferntes Log nicht lesen"
        echo "0"
        return 1
    fi
    return 0
}

function notify {
    msgdate="$(date +%Y-%m-%dT%H:%M:%S)"
    msg=""
    level=$1
    shift
    case "$level" in
        ABORT)
            subject="ABORT"
            urgency="normal"
            head="Backup $friendly_rc abgebrochen"
            timeout="10000"
        ;;
        DEADTIME)
            subject="DEADTIME"
            urgency="low"
            head="Backup $friendly_rc: Braucht noch nicht wieder"
            timeout="2000"
        ;;
        FAIL) # Fehler beim AusfÃ¼hren
            subject="FAIL"
            urgency="critical"
            head="Backup $friendly_rc: Fehler $msgdate"
            timeout="60000"
        ;;
        FATAL) # Fehler im Script / Konfiguration
            subject="WTF!"
            urgency="critical"
            head="Backup-Fehler (Fatal) $friendly_rc"
            timeout="3600000"
        ;;
        START)
            subject="START"
            urgency="low"
            head="Starte Backup $friendly_rc"
            msg="$msgdate"
            timeout="4000"
        ;;
        SUCCESS)
            subject="SUCCESS"
            urgency="low"
            head="Backup $friendly_rc: Erfolg"
            timeout="4000"
        ;;
        *)
            subject="$1"
            timeout="5000"
            urgency="normal"
            head="Backup $friendly_rc"
            shift
        ;;
    esac
    msg="$* $msg"
    notify-send -u $urgency -t $timeout "$head" "$(sed 's/\\n/\n/g' <<<$msg | fold -w 72 -s)"
    verbose_echo "NOTIFY-SEND $head"
    verbose_echo $msg
    loghost=$($config --section notify --key host --default localhost)
    loguser=$($config --section notify --key user --default $LOGNAME)
    logpipe=$($config --section notify --key pipe --emptydefault)
    logremote=$($config --section notify --key remotekey --default $stripped_rc)
    logmsg="content-type: text/x-plain-log\n$logremote\n$subject\n$msg"
    if [ "$logpipe" == "yes" ]; then
        echo -e "$logmsg" | ssh $loguser@$loghost receiver
        if [ $? -ne 0 ]; then
            head="Backup-Fehler $friendly_rc"
            msg="Kann Meldungen nicht auf dem Server schreiben ($?)"
            notify-send -u critical -t 3600000 "$head" "$msg"
            verbose_echo "NOTIFY-SEND $head"
            verbose_echo $msg
        fi
    else
        echo "$logmsg"
    fi
}

rc=rc.ini
force=""
while [ $# -gt 0 ]; do
    case "$1" in
        --config)
            shift;
            if [[ ! -z "$1" ]]; then
                rc=$1
            fi
            shift;
        ;;
        --force)
            shift;
            force="yes"
        ;;
        -v)
            shift;
            verbose=1
        ;;
        *)
            shift;
        ;;
    esac
done
config=""
stripped_rc=${rc/.rc}
stripped_rc=${stripped_rc/.ini}
for rc_variant in $rc $stripped_rc.rc $stripped_rc.ini; do
    config="$exec_dir/config.py --file $rc_variant"
    if $config --doesfileexist --section a --key b; then
        verbose_echo "Config file $rc_variant found"
        break
    fi
    config=""
done
if [ -z "$config" ]; then
    notify FATAL "Konfigurationsscript kann nicht gestartet werden oder Konfigurationsdatei $stripped_rc nicht gefunden"
    exit 127;
fi
friendly_rc=$($config --section info --key friendly_name --default $stripped_rc)
verbose_echo "Friendly name $friendly_rc"

deadtime=$($config --section rsync --key deadtime --default 0)
if [ $deadtime -gt 0 ]; then
    last_string="$(readlog SUCCESS last)"
    if [ "$last_string" == "None" ]; then
        last_string="Jan 1 1970"
    fi
    last_success=$(date +%s -d "$last_string")
    tage=$(( ($(date +%s) - $last_success) / 86400 ))
    if [ $tage -lt $deadtime ]; then
        if [ -z "$force" ]; then
            notify DEADTIME "Letztes erfolgreiches Backup war vor weniger als $deadtime Tagen"
            exit 0;
        fi
        verbose_echo "Deadtime ignored because --force was specified"
    else
        verbose_echo "Deadtime is over"
    fi
else
    verbose_echo "No deadtime given"
fi

notify START "Starte Backup"

# This part should do the actual copying.
source=$($config --section source --key path --emptydefault)
if [ -z "$source" ]; then
    notify FATAL "Kann Quellpfad nicht bestimmen (sollte in source::path stehen)"
    exit 127;
fi
verbose_echo "Source $source"
target=$($config --section target --key path --emptydefault)
if [ -z "$target" ]; then
    notify FATAL "Kann Zielpfad nicht bestimmen (sollte in target::path stehen)"
    exit 127;
fi
verbose_echo "Target $target"
exclude_file=$($config --section source --key exclude_file --emptydefault)
if [ -z "$exclude_file" ]; then
    notify FATAL "Kann nicht bestimmen, welche Dateien vom Backup ausgeschlossen werden sollen (sollte in source::exclude_file stehen)"
    exit 127;
fi
if [[ $exclude_file != /* ]]; then
    exclude_file=$exclude_file
fi
if [ ! -r "$exclude_file" ]; then
    notify FATAL "Kann Datei mit Ausschlussliste $exclude_file nicht lesen"
    exit 127;
fi
verbose_echo "Exclude file $exclude_file"

for part in target source; do
    provide_exe=$($config --section $part --key provide --emptydefault)
    provide_unless=$($config --section $part --key provide_unless --default false)
    if [ ! -z "$provide_exe" ]; then
        if ! $provide_unless; then
            verbose_echo "Need to provide $part via '$provide_exe'"
            eval $provide_exe
            case "$?" in
                0) # normal ok
                ;;
                *)
                    notify FAIL "Bereitstellen von $part mittels $provide_exe fehlgeschlagen ($?)"
                    exit 2
                ;;
            esac
        else
            verbose_echo "No need to provide $part"
        fi
    fi
done

privilege=$($config --section rsync --key privilege --emptydefault)
if [[ "$privilege" -ne "sudo" ]]; then
    privilege=""
fi
no_cross=$($config --section rsync --key no_cross --emptydefault)
if [[ "$no_cross" -ne "-x" ]]; then
    no_cross=""
fi
rsynclogfile=$(date +"$($config --section rsync --key outfile --emptydefault)")
if [[ -z "$rsynclogfile" ]]; then
    rsynclogfile=$(mktemp)
fi
rsyncerrfile=$(mktemp)
verbose_echo "RSYNC privilege $privilege"
verbose_echo "RSYNC no_cross $no_cross"
verbose_echo "RSYNC log file $rsynclogfile"
verbose_echo "RSYNC err file $rsyncerrfile"
$privilege \
rsync --partial -via \
        $no_cross \
        --exclude-from="$exclude_file" \
        $source \
        $target \
        > $rsynclogfile \
        2> $rsyncerrfile
rsync_error=$?

loglines=$(wc -l < $rsynclogfile)
log_in_one_line=$(awk 1 ORS='\\n' "$rsynclogfile")
errlines=$(wc -l < $rsyncerrfile)
err_in_one_line=$(awk 1 ORS='\\n' "$rsyncerrfile")
verbose_echo "RSYNC done, exit code $rsync_error, $loglines log lines, $errlines error lines"
case $rsync_error in
    0)
        notify SUCCESS "output in $rsynclogfile\\n$err_in_one_line";
        exit 0;;
    23|24)
        notify SUCCESS "Nicht alle Quelldateien konnten gelesen werden\\n$rsynclogfile\\n$err_in_one_line";
        exit 0;;
    20)
        notify ABORT "Kopiervorgang abgebrochen $loglines/$errlines Zeilen\\n$err_in_one_line";
        exit 0;;
    [1246])
        notify FATAL "rsync falsch benutzt $rsync_error\\n$err_in_one_line";
        exit 1;;
    3|5|10|11|12|13|14|21|22)
        notify FAIL "rsync copy error $rsync_error\\n$err_in_one_line";
        exit 2;;
    25|40|35)
        notify FAIL "rsync other error $rsync_error\\n$err_in_one_line";
        exit 3;;
    *)
        notify FAIL "Unknown rsync error $rsync_error\\n$err_in_one_line";
        exit $rsync_error;;
esac
