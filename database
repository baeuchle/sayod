#!/bin/bash

exec_dir=$(dirname $0)
source $exec_dir/notify.sh

function cleanup {
    if [ -z "$mysqlerrfile" ]; then
        return
    fi
    if [ -f "$mysqlerrfile" ]; then
        rm $mysqlerrfile
    fi
}
trap cleanup EXIT

rc=rc.ini
temponly=0
nonotify=""
while [ $# -gt 0 ]; do
    case "$1" in
        -c|--config)
            shift;
            if [[ ! -z "$1" ]]; then
                rc=$1
            fi
            shift;
        ;;
        # this is the standard behavior
        -n|--notify)
            shift;
            nonotify=""
        ;;
        # turn off notify-send
        -no-n|--no-notify)
            shift;
            nonotify=1
        ;;
        -q|--quiet)
            shift;
            verbose=""
        ;;
        -t|--temp)
            shift;
            temponly=1
        ;;
        -v|--verbose)
            shift;
            verbose=1
        ;;
        *)
            shift;
        ;;
    esac
done

source $exec_dir/helpers.sh
source $exec_dir/find_config.sh

dbtype=$($config --section database --key type --default sqlite3)
dumpdir=$($config --section database --key directory --default $PWD)
gitdir=$($config --section git --key directory --default "$dumpdir")
gitcmd="git -C $gitdir"
dbsource=$($config --section database --key source --emptydefault)
if [ -z "$dbsource" ]; then
    notify FATAL "Kann Datenquelle nicht bestimmen (sollte in database::source stehen)" 
    exit 1
fi
verbose_echo "Dumping $dbtype database $dbsource to $dumpdir"

if [ "$dbtype" == 'sqlite3' ]; then
    if [ ! -f $dbsource ]; then
        notify FATAL "Database source $dbsource not found"
        exit 1;
    fi
    notify START "Database dump $dbsource started"
    tablelist=$(sqlite3 $dbsource .tables)
    for table in $tablelist; do
        verbose_echo "Dumping table $table"
        sqlite3 $dbsource ".dump $table" > $dumpdir/$table.sql
    done

elif [ "$dbtype" == 'mysql' ]; then
    export MYSQL_PWD="$($config --section database --key password --emptydefault)";
    user=$($config --section database --key user --default $LOGNAME)
    mysqlerrfile=$(mktemp)
    tablelist=$(mysql --user=$user $dbsource -BNe "show tables;" 2>$mysqlerrfile)
    if [ "$?" == "1" ]; then
        notify FATAL "Database table list cannot be read: $(awk 1 ORS='\\n' $mysqlerrfile)"
        exit 1;
    fi
    for table in $tablelist; do
        verbose_echo "Dumping table $table"
        mysqldump --skip-extended-insert --skip-dump-date --user=$user $dbsource $table > $dumpdir/$table.sql 2>$mysqlerrfile
        if [ "$?" == "1" ]; then
            notify FATAL "Table $table in db $dbsource cannot be dumped: $(awk 1 ORS='\\n' $mysqlerrfile)"
            exit 1;
        fi
    done
    unset MYSQL_PWD
fi

if [ "$($config --section git --key commit --default No)" == "No" ]; then
    notify SUCCESS "Database dump complete without source control"
    exit 0;
fi

for table in $tablelist; do
    verbose_echo "Adding $table"
    $gitcmd add $table.sql 2>/dev/null
done

if $gitcmd status --porcelain | grep -qv ^??; then
    # there is something modified, so we will commit:
    msg=$($config --section git --key temp_msg --default "Database $dbsource backup")
    verbose_echo "Committing $msg"
    $gitcmd commit -qm "$msg"
fi

if [ $temponly -eq 1 ]; then
    verbose_echo "Temporary commit only; not pushing"
    notify SUCCESS "Current commit is $($gitcmd log -1 --format=%H)"
    exit 0;
fi

echo "VERBOSE <$verbose>"
echo "NONOTIFY <$nonotify>"
echo "--"
if [ -z "$verbose" ]; then 
    vflag=--quiet
else
    vflag=--verbose
fi
if [ -z "$nonotify" ]; then
    nflag=--no-notify
else
    nflag=--notify
fi
$exec_dir/grand_commit --config $rc $vflag $nflag
exit $?;
