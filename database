#!/usr/bin/python3

"""Dumps database"""

import argparse
import subprocess
from pathlib import Path
import sys
import os

from small_commit import make_small_commit
from config import Config
from notify import Notify
import log
from gitversion import Git

dblog = log.get_logger('database')

def oneline(text):
    return text.replace("\n", " ")

def dumpall(source, directory, notifier, environment, tblcmd, dumpcmd): # pylint: disable=too-many-arguments
    files = []
    notifier.start(f'Database dump {source} started')
    sqltables = subprocess.run(tblcmd, capture_output=True, env=environment, check=False)
    if sqltables.returncode != 0:
        notifier.fatal(f"Database table list cannot be read:\n{oneline(sqltables.stderr)}")
        sys.exit(1)
    for table_bytes in sqltables.stdout.split():
        table = table_bytes.decode('utf-8')
        dblog.info("Dumping table %s", table)
        target = (directory / table).with_suffix('.sql')
        with open(target, 'w+b') as outf:
            with subprocess.Popen([arg.format(table) for arg in dumpcmd],
                    stdout=outf,
                    stderr=subprocess.PIPE,
                    env=environment) as dump_proc:
                errors = dump_proc.stderr.read()
                if dump_proc.wait() != 0:
                    notifier.fatal(f"Table {table} in {source} could not be dumped:\n"
                                   + oneline(errors))
        files.append(target)
    return files

def create_dumps(databasetype, source, path, notifier, **kwargs):
    env = os.environ()
    tblcmd = []
    dumpcmd = []
    if databasetype == 'sqlite3':
        if not Path(source).exists():
            notifier.fatal(f'Database source {source} not found')
            sys.exit(1)
        tblcmd = ['sqlite3', source, '.tables']
        dumpcmd = ['sqlite3', source, '.dump {}']
    if databasetype == 'mysql':
        env['MYSQL_PWD'] = kwargs.get('password', '')
        username = kwargs.get('username', '')
        tblcmd = ['mysql', '--user='+username, source, '-BNe', 'show tables']
        dumpcmd = ['mysqldump', '--user='+username, '--skip-extended-insert',
            '--skip-dump-date', source, '{}']
    return dumpall(source, path, notifier, env, tblcmd, dumpcmd)

parser = argparse.ArgumentParser(description="""Dumps a database""")
Config.add_options(parser)
log.add_options(parser)
Notify.add_options(parser)
args = parser.parse_args()

dblog = log.get_logger('database', args)
config = Config.get_config(args)
notify = Notify(config, show=not args.notification_dontshow)

dbtype = config.find('database', 'type', 'sqlite3')
dumpdir = config.find('database', 'directory', Path.cwd())
dumppath = Path(dumpdir)
git = Git(config.find('git', 'directory', dumpdir))
dbsource = config.find('database', 'source', None)
if not dbsource:
    notify.fatal("Kann Datenquelle nicht bestimmen (sollte in database::source stehen)")
    sys.exit(1)

dblog.info("Dumping %s database %s to %s", dbtype, dbsource, dumpdir)

filelist = create_dumps(dbtype, dbsource, dumppath, notify,
        password=config.find('database', 'password', ''),
        username=config.find('database', 'user', config.find('env', 'LOGNAME'))
    )

if not config.find('git', 'commit', False):
    notify.success("Database dump complete without source control")
    sys.exit(0)

make_small_commit(config, git, notify, addables=filelist)
sys.exit(0)
