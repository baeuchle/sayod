#!/usr/bin/python3

"""Creates a grand git commit"""

import argparse
from datetime import datetime
from pathlib import Path
import sys
from gitversion import Git
from config import Config
from notify import Notify
import log

parser = argparse.ArgumentParser(description="""Creates a grand commit

For a given git repository, this takes all changes since tag "stable"*
and packs them together into one grand commit.

The purpose is to have a fine-grained short-term backup -- the small
commit -- but only a coarser long-term backup, provided by grand commit.

The grand commit is also mirrored.""",
    epilog="""*: this name is subject to configuration""")
Config.add_options(parser)
log.add_options(parser)
Notify.add_options(parser)
args = parser.parse_args()

log = log.get_logger('grand_commit', args)
config = Config.get_config(args)
notify = Notify(config, show=not args.notification_dontshow)
git = Git(config.find('git', 'directory', Path.cwd()))

tagname = config.find('git', 'tagname', 'stable')
if tagname + "\n" in git.commandlines('tag'):
    log.info("Resetting to tag %s", tagname)
    git.command('reset', '--soft', tagname)
    if git.there_are_untracked_files():
        msg = config.find('git', 'grand_message', 'Grand backup').format(datetime.now())
        log.info("Committing %s", msg)
        git.command('commit', '-qm', msg)
    else:
        log.info("No changes")
    git.command('tag', '-d', tagname)

log.info("Creating new tag %s", tagname)
git.command('tag', tagname)
for orig in config.find('git', 'origins', 'origin').split():
    log.info('Pushing to origin %s', orig)
    git.command('push', '-q', orig, 'master')

notify.success("Current commit is", git.hash())
sys.exit(0)
